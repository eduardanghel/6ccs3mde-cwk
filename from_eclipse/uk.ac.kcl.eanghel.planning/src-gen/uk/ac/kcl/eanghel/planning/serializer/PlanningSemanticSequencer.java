/*
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.eanghel.planning.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.eanghel.planning.planning.AnalyseTask;
import uk.ac.kcl.eanghel.planning.planning.BugTask;
import uk.ac.kcl.eanghel.planning.planning.DeployTask;
import uk.ac.kcl.eanghel.planning.planning.DocumentTask;
import uk.ac.kcl.eanghel.planning.planning.FeatureTask;
import uk.ac.kcl.eanghel.planning.planning.Owner;
import uk.ac.kcl.eanghel.planning.planning.PlanningPackage;
import uk.ac.kcl.eanghel.planning.planning.Points;
import uk.ac.kcl.eanghel.planning.planning.Project;
import uk.ac.kcl.eanghel.planning.planning.TaskPlanning;
import uk.ac.kcl.eanghel.planning.planning.Tasks;
import uk.ac.kcl.eanghel.planning.planning.TestTask;
import uk.ac.kcl.eanghel.planning.services.PlanningGrammarAccess;

@SuppressWarnings("all")
public class PlanningSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PlanningGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PlanningPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PlanningPackage.ANALYSE_TASK:
				sequence_AnalyseTask(context, (AnalyseTask) semanticObject); 
				return; 
			case PlanningPackage.BUG_TASK:
				sequence_BugTask(context, (BugTask) semanticObject); 
				return; 
			case PlanningPackage.DEPLOY_TASK:
				sequence_DeployTask(context, (DeployTask) semanticObject); 
				return; 
			case PlanningPackage.DOCUMENT_TASK:
				sequence_DocumentTask(context, (DocumentTask) semanticObject); 
				return; 
			case PlanningPackage.FEATURE_TASK:
				sequence_FeatureTask(context, (FeatureTask) semanticObject); 
				return; 
			case PlanningPackage.OWNER:
				sequence_Owner(context, (Owner) semanticObject); 
				return; 
			case PlanningPackage.POINTS:
				sequence_Points(context, (Points) semanticObject); 
				return; 
			case PlanningPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case PlanningPackage.TASK_PLANNING:
				sequence_TaskPlanning(context, (TaskPlanning) semanticObject); 
				return; 
			case PlanningPackage.TASKS:
				sequence_Tasks(context, (Tasks) semanticObject); 
				return; 
			case PlanningPackage.TEST_TASK:
				sequence_TestTask(context, (TestTask) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     TaskType returns AnalyseTask
	 *     AnalyseTask returns AnalyseTask
	 *
	 * Constraint:
	 *     analyse=STRING
	 */
	protected void sequence_AnalyseTask(ISerializationContext context, AnalyseTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlanningPackage.Literals.ANALYSE_TASK__ANALYSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanningPackage.Literals.ANALYSE_TASK__ANALYSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnalyseTaskAccess().getAnalyseSTRINGTerminalRuleCall_1_0(), semanticObject.getAnalyse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TaskType returns BugTask
	 *     BugTask returns BugTask
	 *
	 * Constraint:
	 *     bug=STRING
	 */
	protected void sequence_BugTask(ISerializationContext context, BugTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlanningPackage.Literals.BUG_TASK__BUG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanningPackage.Literals.BUG_TASK__BUG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBugTaskAccess().getBugSTRINGTerminalRuleCall_1_0(), semanticObject.getBug());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TaskType returns DeployTask
	 *     DeployTask returns DeployTask
	 *
	 * Constraint:
	 *     deploy=STRING
	 */
	protected void sequence_DeployTask(ISerializationContext context, DeployTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlanningPackage.Literals.DEPLOY_TASK__DEPLOY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanningPackage.Literals.DEPLOY_TASK__DEPLOY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeployTaskAccess().getDeploySTRINGTerminalRuleCall_1_0(), semanticObject.getDeploy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TaskType returns DocumentTask
	 *     DocumentTask returns DocumentTask
	 *
	 * Constraint:
	 *     doc=STRING
	 */
	protected void sequence_DocumentTask(ISerializationContext context, DocumentTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlanningPackage.Literals.DOCUMENT_TASK__DOC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanningPackage.Literals.DOCUMENT_TASK__DOC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDocumentTaskAccess().getDocSTRINGTerminalRuleCall_1_0(), semanticObject.getDoc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TaskType returns FeatureTask
	 *     FeatureTask returns FeatureTask
	 *
	 * Constraint:
	 *     feat=STRING
	 */
	protected void sequence_FeatureTask(ISerializationContext context, FeatureTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlanningPackage.Literals.FEATURE_TASK__FEAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanningPackage.Literals.FEATURE_TASK__FEAT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureTaskAccess().getFeatSTRINGTerminalRuleCall_1_0(), semanticObject.getFeat());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Owner returns Owner
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Owner(ISerializationContext context, Owner semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlanningPackage.Literals.OWNER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanningPackage.Literals.OWNER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOwnerAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Points returns Points
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Points(ISerializationContext context, Points semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlanningPackage.Literals.POINTS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanningPackage.Literals.POINTS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointsAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Project returns Project
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Project(ISerializationContext context, Project semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlanningPackage.Literals.PROJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanningPackage.Literals.PROJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProjectAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TaskPlanning returns TaskPlanning
	 *
	 * Constraint:
	 *     (name=ID owners+=Owner+ projs+=Project+ tasks+=Tasks*)
	 */
	protected void sequence_TaskPlanning(ISerializationContext context, TaskPlanning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tasks returns Tasks
	 *
	 * Constraint:
	 *     (
	 *         taskType=TaskType 
	 *         owner+=[Owner|ID]+ 
	 *         priority=INT 
	 *         points=Points 
	 *         status=Status 
	 *         proj+=[Project|ID]+
	 *     )
	 */
	protected void sequence_Tasks(ISerializationContext context, Tasks semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TaskType returns TestTask
	 *     TestTask returns TestTask
	 *
	 * Constraint:
	 *     test=STRING
	 */
	protected void sequence_TestTask(ISerializationContext context, TestTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlanningPackage.Literals.TEST_TASK__TEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanningPackage.Literals.TEST_TASK__TEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTestTaskAccess().getTestSTRINGTerminalRuleCall_1_0(), semanticObject.getTest());
		feeder.finish();
	}
	
	
}
