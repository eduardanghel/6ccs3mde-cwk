/**
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.eanghel.planning.validation;

import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import uk.ac.kcl.eanghel.planning.planning.Owner;
import uk.ac.kcl.eanghel.planning.planning.PlanningPackage;
import uk.ac.kcl.eanghel.planning.planning.Points;
import uk.ac.kcl.eanghel.planning.planning.TaskPlanning;
import uk.ac.kcl.eanghel.planning.planning.Tasks;
import uk.ac.kcl.eanghel.planning.typing.validation.PlanningTypeSystemValidator;

/**
 * This class contains custom validation rules.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class PlanningValidator extends PlanningTypeSystemValidator {
  public static final String INVALID_STORY_POINT = "uk.ac.kcl.eanghel.planning.INVALID_STORY_POINT";
  
  public static final String DUPLICATE_OWNER = "uk.ac.kcl.eanghel.planning.DUPLICATE_OWNER";
  
  public static final String INVALID_OWNER = "uk.ac.kcl.eanghel.planning.INVALID_OWNER";
  
  public static final String PRIORITY_TOO_HIGH = "uk.ac.kcl.eanghel.planning.PRIORITY_TOO_HIGH";
  
  @Check
  void checkStoryPointsFibonacci(final Points points) {
    List<Integer> fibList = Arrays.<Integer>asList(Integer.valueOf(0), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(5), Integer.valueOf(8), Integer.valueOf(13), Integer.valueOf(21), Integer.valueOf(34), Integer.valueOf(55), Integer.valueOf(89));
    boolean _contains = fibList.contains(Integer.valueOf(points.getValue()));
    boolean _not = (!_contains);
    if (_not) {
      this.error(
        "The amount of story points needs to a Fibonacci number lower than 100", points, 
        PlanningPackage.Literals.POINTS__VALUE, PlanningValidator.INVALID_STORY_POINT);
    }
  }
  
  @Check
  public void checkDuplicateOwners(final TaskPlanning tasks) {
    EList<Owner> owners = tasks.getOwners();
    for (int i = 0; (i < owners.size()); i++) {
      for (int j = (i + 1); (j < owners.size()); j++) {
        boolean _equals = owners.get(i).getName().equals(owners.get(j).getName());
        if (_equals) {
          this.error("Cannot declare duplicate owners.", tasks, 
            PlanningPackage.Literals.TASK_PLANNING__OWNERS, PlanningValidator.DUPLICATE_OWNER);
        }
      }
    }
  }
  
  @Check
  public void checkOwnersAreUppercased(final Owner owner) {
    boolean _isUpperCase = Character.isUpperCase(owner.getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.error("Owners\' names must start with a capital letter.", owner, 
        PlanningPackage.Literals.OWNER__NAME, PlanningValidator.INVALID_OWNER);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkPriorityIsNotOverstated(final Tasks tasks) {
    int _priority = tasks.getPriority();
    boolean _greaterThan = (_priority > 10);
    if (_greaterThan) {
      this.info("Make sure you don\'t overstate your priorities.", null);
    }
    int _priority_1 = tasks.getPriority();
    boolean _greaterThan_1 = (_priority_1 > 20);
    if (_greaterThan_1) {
      this.warning("This priority is quite high.", null);
    }
    int _priority_2 = tasks.getPriority();
    boolean _greaterThan_2 = (_priority_2 > 25);
    if (_greaterThan_2) {
      this.error("Priority too high.", tasks, 
        PlanningPackage.Literals.TASKS__PRIORITY, PlanningValidator.PRIORITY_TOO_HIGH);
    }
  }
}
